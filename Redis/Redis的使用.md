## 一、Redis 键(Key) 构成

```c
typedef struct redisObject { 
	unsigned type:4;//类型 五种对象类型  REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。
	unsigned encoding:4; //编码 4表示位数
	void *ptr;//指向底层实现数据结构的指针,指向具体数据
	//... 
	int refcount;//引用计数 
	//... 
	unsigned lru:LRU_BITS; //LRU_BITS为24bit 记录最后一次被命令程序访问的时间 
        //高16位存储一个分钟数级别的时间戳&#xff0c;低8位存储访问计数&#xff08;lfu &#xff1a; 最近访问次数&#xff09;
	//... 
} robj;
```

1. 查看对象类型 `type key`

   ![image-20210819160437641](../img/redis_01.png)

2. 获取value具体编码 `object encoding key`

   ![image-20210819161346762](../img/redis_02.png)

   > 可以看出，value为string类型的，编码可以有3种：`embstr`，`int`，`raw`；当字符串长度大于44(整个sds总体超过64)时，就用raw存储。sds结构自身占用19个字节，字符串结尾标识"\0"占一个字节，所以**64 - 19 -1 = 44**

3. 查看key的结构信息 `debug object key`

   ![image-20210819173859796](../img/redis_03.png)

## 二、Redis二进制安全

1.  什么是二进制安全？

   二进制安全就是指，在传输数据时，保证二进制数据的信息安全，即不被篡改、破译等。简单来说，就是只关心二进制化的字符串，不关心具体格式，只会严格的按照二进制数据存取，不会妄图以某种特殊格式解析数据。例如：在C语言中，就以"\0"来判定字符串的结尾。

2. Redis是如何保证二进制安全的？

   ```c
   struct sdshdr{
           int len;//buf数组中已经使用的字节的数量&#xff0c;也就是SDS字符串长度
           int  free;//buf数组中未使用的字节的数量
           char buf[];//字节数组&#xff0c;字符串就保存在这里面
   };
   ```

   Redis 通过定义上述结构体的方式，扩展了C语言底层字符串的缺点；不再像C语言那样，以"\0"作为字符串的结尾，而是使用了独立的`len`字段来表示字符串的长度。这样就避免了如果字符串中出现"\0"而被截取忽略后面字符串的问题；保证了二进制安全。

   > 基于此，Redis的string可以支持各种类型(图片、视频、文本等)；而C语言的字符串就只能存储文本格式的数据。

   ![redis_string_sds](../img/redis_04.png)

3. Redis的简单动态字符串SDS对比C语言中的字符串char，有什么优势？

   * 可以在O(1)的时间复杂度得到字符串的长度 (sds结构中，len字段直接记录了长度)

   * 二进制安全 

   * 可以高效的追加字符串操作

     原理：sds会判断当前字符串空余(free)的长度与需要追加的字符串长度；如果空余大于需要追加，就会直接追加，减少了重新分配内存的操作；如果空余小于需要追加，那么就先对sds进行扩展，然后再追加；只是这里扩展内存是按照一定的机制进行的，扩展后多余的空间不释放，方便下次追加字符串，会造成一定的内存浪费，但是在频繁追加操作下，这种机制就很高效。

4. SDS 内存扩展机制

   在已经分配的内存低于1M时，每次扩容都是以现有内存2倍的方式扩容；当超过1M时，每次只扩容1M

